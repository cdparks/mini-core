main = double 21;

-- Test let/letrec indentation
double x = let y = x + x;
               z = x * x;
               m = x - x
           in y;

double2 x = letrec y = x + x;
                   z = x * x;
                   m = x - x
            in y;

-- Prelude definitions; test application precedence
I x = x;
K x y = x;
K1 x y = y;
S f g x = f x (g x);
compose f g x = f (g x);
twice f = compose f f;

-- Booleans
False = Pack{0,0};
True = Pack{1,0};

-- Lists
Nil = Pack{2,0};
Cons = Pack{3,2};

-- range 1 5 -> [1, 2, 3, 4]
range start stop = case start < stop of
                        <0> -> Nil;
                        <1> -> Cons start (range (start + 1) stop);

-- Calculate length by analysis on list 
length ls = case ls of
                 <2> -> 0;
                 <3> x xs -> 1 + length xs;

-- Sillier way to do the same thing
length2 ls = case ls of
                  <2> -> 0;
                  <3> x xs -> case xs of
                                   <2> -> 1;
                                   <3> y ys -> case ys of
                                                    <2> -> 2;
                                                    <3> z zs -> 3 + length2 zs;

-- Fixed point combinator
fix f = f (fix f);

-- Define factorial using an anonymous function
factorial = fix (\f n -> case n < 2 of
                              <1> -> 1;
                              <0> -> n * f (n - 1));

-- More precedence testing
mulAdd x = x * x + x * x;
mulAppAdd x = f (x * x) + f (x * x);
addMul x = (x + x) * (x + x);
addAppMul x = f (x + x) * f (x + x)

